# Hoisting

`Hoist` = 감아올리다(끌어올리다)

> 인터프리터가 **변수와 함수의 메모리 공간을 선언 전에 미리 할당**해 두는 것으로,<br />
> 변수, 함수의 선언부가 위치한 인접한 scope의 시작지점에서부터 해당 식별자의 인식이 가능한 현상이라고 이해할 수 있다.

## 호이스팅의 규칙

1. 선언된 `함수`는 상단에서 참조, 호출이 **가능**하다.
2. 선언된 `var`는 상단에서 참조, 호출이 **가능**하다.
3. 선언된 `let`, `const`는 상단에서 참조, 호출이 **불가능**하다.

## 호이스팅의 대상

함수표현식과 `var`는 물론, `let`, `const`를 포함하여 모든 선언의 호이스팅 하게 된다.<br />
크게 함수 호이스팅과 변수 호이스팅으로 나누어 알아보자.

### 함수 호이스팅(funcion hoisting)

함수 호이스팅은 그 무엇보다 **가장 먼저** 이루어진다.<br />
함수표현식은 결국에는 어떤 변수에 함수를 할당하는 모양이기 때문에 이 또한 변수 호이스팅 사례라고 볼 수 있다.

```javascript
var func = function () {};
```

함수의 선언문은 식별자가 변수 객체에 수집될 때 부가적으로 해당 함수 참조에 대한 초기화까지 자동으로 이루어진다. 그렇기 때문에 선언된 함수는 상단에서 참조, 호출이 가능하다.

### 변수 호이스팅(variable hoisting)

변수는 3단계를 거치면서 생성되게 된다.

1. 선언 단계<br />
   파싱단계에서 변수객체가 변수에 대한 식별자를 수집하게 되는데, 이 변수객체는 scope가 참조하는 대상이 된다.
2. 초기화 단계<br />
   변수객체에 등록된 변수를 위한 공간을 메모리에 확보하는 단계로, 이 때 변수는 `undefined` 상태를 부여한다.
3. 할당 단계<br />
   초기화된 변수에 실제 값을 할당하는 단계

함수표현식과 마찬가지로, 변수 또한 선언과 초기화를 해주어야 값의 참조, 할당이 가능해진다. 다만 선언한 방식에 따라서 선언, 초기화 시점이 달라지기 때문에 유의해서 사용해야 한다.

- `var`로 선언된 변수는 **변수 선언단계와 초기화 단계가 한번에 진행**된다.<br />
  ➔ 선언단계에서 `undefined`로 초기화를 시켜버리기 때문에, 변수 선언문 이전에 변수에 접근해도 에러가 아닌 `undefined`를 출력하게 되는 것.<br />
  = 실행 시점의 scope 최상단에서 선언된 변수에 대한 메모리가 살아있기 때문에 선언 위치에 상관없이 참조, 할당이 가능해지는 것이다.
- `let`, `const`로 선언된 변수는 **변수 선언단계와 초기화단계가 분리**되어 이루어진다.<br />
  ➔ 때문에 scope에 변수를 등록(선언) 하지만, 초기화단계는 변수 선언문에 도달했을 때 이루어지므로, 초기화 이전에 변수에 접근하려 하면 참조에러(`ReferenceError`)가 발생하게 된다.<br />
  = 변수 선언과 scope의 최상단의 간극만큼은 선언된 변수에 대한 메모리가 존재하지 않기 때문에, 선언부 상단에서의 참조, 할당은 불가능하다.

#### 일시적 사각지대(= TDZ(Temporal Dead Zone))

`let`, `const` 가 동작하는 과정에서 스코프의 진입지점과 해당 식별자의 실질적 선언부 사이를 일시적 사각지대(TDZ)라고 한다. 이 구역에서 변수는 존재하지만, 초기화가 되어있지 않다.

```javascript
// var 사용 시
(function test() {
  console.log(a);
  var a;
})(); // undefined => var로 선언한 a는, 선언과 동시에 undefined로 초기화 설정이 된다.

// let 사용 시
(function test() {
  console.log(b); // TDZ구간
  let b;
})(); // ReferenceError => let으로 선언한 b는, 선언만 됬을 뿐 초기화 설정이 되지 않기 때문에 참조에러가 난다.
```

#### ⚠️ let과 const는 호이스팅이 되는게 맞는가

여러개의 글을 읽어보고 내린 결론은, '**된다**'는 것이다.<br />
위의 코드에서 확인해볼 수 있듯이, TDZ 구간이 있다는 것은 변수 자체는 존재한다는 것으로, 실질적으로 할당해서 사용하지는 못하는 것일 뿐이다.

`호이스팅은 인접 스코프의 상단에서 선언부를 관측할 수 있는 현상`이라는 설명에 빗대어 보면 `let` 과 `const` 또한 **호이스팅 대상이라고 보는 게 맞다.**

> 참고하였습니다 :)

- [velog에 작성한 포스팅](https://velog.io/@eassy/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)
- [호이스팅에 대한 오해와 진실](https://tecoble.techcourse.co.kr/post/2021-04-25-hoisting/)
